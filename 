warning: in the working copy of 'src/ADS1220_NTC_Extended.cpp', LF will be replaced by CRLF the next time Git touches it
warning: in the working copy of 'src/ADS1220_NTC_Extended.h', LF will be replaced by CRLF the next time Git touches it
[1mdiff --git a/src/ADS1220_NTC_Extended.cpp b/src/ADS1220_NTC_Extended.cpp[m
[1mindex 24cbce6..d816204 100644[m
[1m--- a/src/ADS1220_NTC_Extended.cpp[m
[1m+++ b/src/ADS1220_NTC_Extended.cpp[m
[36m@@ -46,6 +46,9 @@[m [mADS1220_NTC_Extended::ADS1220_NTC_Extended(uint8_t csPin, uint8_t drdyPin) {[m
     // Corriente IDAC por defecto[m
     _idacCurrent = ADS1220_IDAC_CURRENT;[m
     [m
[32m+[m[32m    // Ganancia por defecto[m
[32m+[m[32m    _currentGain = 1;[m
[32m+[m[41m    [m
     // Inicializar moving average[m
     _avgSize = 5;[m
     for (int ch = 0; ch < 2; ch++) {[m
[36m@@ -104,6 +107,20 @@[m [mbool ADS1220_NTC_Extended::begin(SPIClass *spiInstance) {[m
     _reg0 = ADS1220_MUX_AIN0_AIN1 | ADS1220_GAIN_1 | ADS1220_PGA_ENABLED;[m
     writeRegister(ADS1220_REG0, _reg0);[m
     [m
[32m+[m[32m    // Extraer y guardar ganancia configurada[m
[32m+[m[32m    uint8_t gainBits = (_reg0 >> 1) & 0x07;[m
[32m+[m[32m    switch(gainBits) {[m
[32m+[m[32m        case 0: _currentGain = 1; break;[m
[32m+[m[32m        case 1: _currentGain = 2; break;[m
[32m+[m[32m        case 2: _currentGain = 4; break;[m
[32m+[m[32m        case 3: _currentGain = 8; break;[m
[32m+[m[32m        case 4: _currentGain = 16; break;[m
[32m+[m[32m        case 5: _currentGain = 32; break;[m
[32m+[m[32m        case 6: _currentGain = 64; break;[m
[32m+[m[32m        case 7: _currentGain = 128; break;[m
[32m+[m[32m        default: _currentGain = 1; break;[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
     _reg1 = ADS1220_DR_90SPS | ADS1220_MODE_NORMAL | ADS1220_CM_CONTINUOUS;[m
     writeRegister(ADS1220_REG1, _reg1);[m
     [m
[36m@@ -368,8 +385,41 @@[m [mfloat ADS1220_NTC_Extended::readThermalPowerFiltered(ADS1220_Channel channel, fl[m
 // =============================================================================[m
 [m
 void ADS1220_NTC_Extended::setGain(uint8_t gain) {[m
[32m+[m[32m    // Actualizar registro del hardware[m
     _reg0 = (_reg0 & 0xF1) | (gain & 0x0E);[m
     writeRegister(ADS1220_REG0, _reg0);[m
[32m+[m[41m    [m
[32m+[m[32m    // Guardar valor num√©rico de ganancia[m
[32m+[m[32m    // Convertir bits de registro a valor num√©rico[m
[32m+[m[32m    uint8_t gainBits = (gain >> 1) & 0x07;[m
[32m+[m[32m    switch(gainBits) {[m
[32m+[m[32m        case 0: _currentGain = 1; break;[m
[32m+[m[32m        case 1: _currentGain = 2; break;[m
[32m+[m[32m        case 2: _currentGain = 4; break;[m
[32m+[m[32m        case 3: _currentGain = 8; break;[m
[32m+[m[32m        case 4: _currentGain = 16; break;[m
[32m+[m[32m        case 5: _currentGain = 32; break;[m
[32m+[m[32m        case 6: _currentGain = 64; break;[m
[32m+[m[32m        case 7: _currentGain = 128; break;[m
[32m+[m[32m        default: _currentGain = 1; break;[m
[32m+[m[32m    }[m
[32m+[m[32m}[m
[32m+[m
[32m+[m[32mvoid ADS1220_NTC_Extended::setPGABypass(bool bypass) {[m
[32m+[m[32m    // Bit 0 de Registro 0: PGA_BYPASS[m
[32m+[m[32m    // 0 = PGA habilitado (default)[m
[32m+[m[32m    // 1 = PGA deshabilitado (bypass)[m
[32m+[m[41m    [m
[32m+[m[32m    if (bypass) {[m
[32m+[m[32m        _reg0 |= ADS1220_PGA_BYPASSED;   // Set bit 0 = 1[m
[32m+[m[32m    } else {[m
[32m+[m[32m        _reg0 &= ~ADS1220_PGA_BYPASSED;  // Clear bit 0 = 0[m
[32m+[m[32m    }[m
[32m+[m[41m    [m
[32m+[m[32m    writeRegister(ADS1220_REG0, _reg0);[m
[32m+[m[41m    [m
[32m+[m[32m    // Nota: Al deshabilitar PGA, solo ganancias 1, 2, 4 est√°n disponibles[m
[32m+[m[32m    // Ganancias mayores requieren PGA habilitado[m
 }[m
 [m
 void ADS1220_NTC_Extended::setDataRate(uint8_t dataRate) {[m
[36m@@ -615,7 +665,11 @@[m [muint8_t ADS1220_NTC_Extended::_getCurrentRegisterSetting(float desiredCurrent_uA[m
 // =============================================================================[m
 [m
 float ADS1220_NTC_Extended::rawToVoltage(int32_t rawValue) {[m
[31m-    return ((float)rawValue / (float)ADS1220_MAX_CODE) * ADS1220_VREF;[m
[32m+[m[32m    // F√≥rmula correcta del datasheet: VIN = (Code √ó VREF) / (Gain √ó 2^23)[m
[32m+[m[32m    // Donde 2^23 = 8,388,608 (usamos ADS1220_MAX_CODE = 8,388,607)[m
[32m+[m[32m    float numerator = (float)rawValue * ADS1220_VREF;[m
[32m+[m[32m    float denominator = (float)_currentGain * (float)ADS1220_MAX_CODE;[m
[32m+[m[32m    return numerator / denominator;[m
 }[m
 [m
 float ADS1220_NTC_Extended::voltageToResistance(float voltage) {[m
[1mdiff --git a/src/ADS1220_NTC_Extended.h b/src/ADS1220_NTC_Extended.h[m
[1mindex 21734bb..8bb5c50 100644[m
[1m--- a/src/ADS1220_NTC_Extended.h[m
[1m+++ b/src/ADS1220_NTC_Extended.h[m
[36m@@ -323,6 +323,7 @@[m [mpublic:[m
     [m
     // ===== FUNCIONES DE CONFIGURACI√ìN DEL ADC =====[m
     void setGain(uint8_t gain);[m
[32m+[m[32m    void setPGABypass(bool bypass);[m
     void setDataRate(uint8_t dataRate);[m
     void setConversionMode(uint8_t mode);[m
     [m
[36m@@ -359,6 +360,9 @@[m [mprivate:[m
     // Corriente IDAC real (en amperes)[m
     float _idacCurrent;[m
     [m
[32m+[m[32m    // Ganancia actual del PGA (valor num√©rico: 1, 2, 4, 8, 16, 32, 64, 128)[m
[32m+[m[32m    uint8_t _currentGain;[m
[32m+[m[41m    [m
     // Buffer para moving average (usado tanto para NTC como para Heat Flux)[m
     static const uint8_t MAX_AVG_SIZE = 20;[m
     float _tempBuffer[2][MAX_AVG_SIZE];  // Buffer gen√©rico para ambos modos[m
